package PACKAGE_NAME.ProducerConsumer;

public class Definition {
    /**
     * 应用场景：生产者和消费者问题
     * 假设仓库中只能存放一件产品，生产者将生产出来的产品放入仓库，消费者将仓库中产品取走消费
     * 如果仓库中没有产品，则生产者将产品放入仓库，否则停止生产并等待，直到仓库中的产品被消费者取走为止
     * 如果仓库中放有产品，则消费者可以将产品取走消费，否则停止消费并等待，直到仓库中再次放入产品为止
     *
     * 这是一个线程同步问题，生产者和消费者共享同一个资源，并且生产者和消费者之间相互依赖，互为条件：
     * 对于生产者，没有生产产品之前，要通知消费者等待，而生产了产品之后，又要马上通知消费者消费
     * 对于消费者，在消费之后，要通知生产者已经结束消费，需要生产新的产品以供消费
     *
     * 在生产者消费者问题中，仅有synchronized是不够的
     * synchronized可以组织并发更新同一个共享资源，实现了同步
     * synchronized不能用来实现不同线程之间的消息传递（通信）
     */
    /**
     * Java提供了几个方法解决线程之间的通信问题
     * wait() 表示线程一直等待，直到其他线程通知，与sleep不同，会释放锁
     * wait(long timeout) 指定等待的毫秒数
     * notify（）唤醒一个处于等待状态的线程
     * notifyAll() 唤醒同一个对象上所有调用wait()方法的线程，优先级别高的线程优先调度
     *
     * 注意： 均是Object类的方法，都只能在同步方法或者同步代码块中使用，否则会抛出异常IIIegalMonitorStateException
     */
    /**
     * 并发协作模型"生产者/消费者模式"--->管程法
     * 生产者：负责生产数据的模块（可能是方法，对象，线程，进程）
     * 消费者：负责处理数据的模块（可能是方法，对象，线程，进程）
     * 缓冲区：消费者不能直接使用生产者的数据，他们之间有个”缓冲区“
     * 生产者将生产好的数据放入缓冲区，消费者从缓冲区拿数据
     */
    /**
     * 并发协作模型"生产者/消费者模式"--->信号灯法
     */
}
